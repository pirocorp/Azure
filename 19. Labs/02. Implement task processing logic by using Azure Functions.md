# Implement task processing logic by using Azure Functions

# Architecture diagram

![image](https://user-images.githubusercontent.com/34960418/167836523-f0d3ccc4-3af7-4de2-a39c-e147c8be8166.png)


# Create Azure resources

## Log in to [Azure Portal](https://portal.azure.com/)

## Create an Azure Storage account

In the Azure portal, use the **Search resources, services, and docs** text box to search for **Storage Accounts**, and then, in the list of results, select **Storage Accounts**. On the **Storage accounts** blade, select **+ Create**.

![image](https://user-images.githubusercontent.com/34960418/167845371-5e6d4226-cc30-4607-8752-bddf3c06bfe2.png)


On the **Create a storage account** blade, on the **Basics** tab, perform the following actions, and then select **Review + create**:

| Setting                           | Action                                                       |
| --------------------------------- | ------------------------------------------------------------ |
| **Subscription** drop-down list   | Retain the default value.                                    |
| **Resource group** section        | Select **Create new**, enter **Serverless**, and then select **OK**. |
| **Storage account name** text box | Enter **funcstor**_[yourname]_.                              |
| **Region** drop-down list         | Select **(US) East US**.                                     |
| **Performance** section           | Select the **Standard** option.                              |
| **Redundancy** drop-down list     | Select **Locally-redundant storage (LRS)**.                  |

The following screenshot displays the configured settings in the **Create a storage account** blade.

![image](https://user-images.githubusercontent.com/34960418/167845766-9a7686ee-418c-454e-932a-4c20d7fe6b53.png)


On the **Review + create** tab, review the options that you selected during the previous steps. Select **Create** to create the storage account by using your specified configuration.

> **Note**: Wait for the creation task to complete before you proceed with this lab.

On the **Overview** blade, select the **Go to resource** button to navigate to the blade of the newly created storage account.

![image](https://user-images.githubusercontent.com/34960418/167846101-39ae3c3d-2145-494d-bb38-893cabbee9c8.png)


On the **Storage account** blade, in the **Security + networking** section, select **Access keys**. On the **Access keys** blade, select **Show keys**. Review any one of the keys, and then copy the value of either of the **Connection string** boxes to the clipboard.

![image](https://user-images.githubusercontent.com/34960418/167846610-06a45c54-a431-4973-b037-cff83dec1644.png)

> **Note**: It doesn't matter which connection string you choose. They are interchangeable.

Open Notepad, and then paste the copied connection string value to Notepad. You'll use this value later in this lab.


## Create a function app

On the Azure portal's navigation pane, select the **Create a resource** link. On the **Create a resource** blade, in the **Search services and marketplace** text box, enter **Function**, and then select Enter. On the **Marketplace** search results blade, select the **Function App** result. On the **Function App** blade, select **Create**.

![image](https://user-images.githubusercontent.com/34960418/167847288-a5b39ddf-e61f-4fdb-b2ed-91ae8b976fa3.png)


 On the **Create Function App** blade, on the **Basics** tab, perform the following actions, and then select **Next: Hosting**:

| Setting                          | Action                           |
| -------------------------------- | -------------------------------- |
| **Subscription** drop-down list  | Retain the default value.        |
| **Resource group** section       | Select **Serverless**.           |
| **Function App name** text box   | Enter **funclogic**_[yourname]_. |
| **Publish** section              | Select **Code**.                 |
| **Runtime stack** drop-down list | Select **.NET**.                 |
| **Version** drop-down list       | Select **3.1**.                  |
| **Region** drop-down list        | Select the **East US** region.   |
| **Operating System** section     | Select **Linux**.                |
| **Plan type** drop-down list     | Select **Consumption (Serverless)**. |

The following screenshot displays the configured settings in the **Create Function App** blade.

![image](https://user-images.githubusercontent.com/34960418/167847998-2a49cce0-0c04-4b71-b383-2ddc19df0160.png)


On the **Hosting** tab, perform the following actions, and then select **Review + create**:

| Setting                            | Action                                             |
| ---------------------------------- | -------------------------------------------------- |
| **Storage account** drop-down list | Select the **funcstor**_[yourname]_ storage account. |

The following screenshot displays the configured settings on the **Hosting** tab on the **Create Function App** blade.

![image](https://user-images.githubusercontent.com/34960418/167848713-d17ddb25-6ef1-4090-ab78-d807858e5d0a.png)


On the **Review + create** tab, review the options that you selected during the previous steps. Select **Create** to create the function app by using your specified configuration.

> **Note**: Wait for the creation task to complete before you move forward with this lab.


## Review

In this exercise, you created all the resources that you'll use in this lab.


# Configure a local Azure Functions project

## Initialize a function project

Open **Windows Terminal**, and open the directory project. Run the following command to use the **Azure Functions Core Tools** to create a new local Azure Functions project in the current directory using the **dotnet** runtime:

```bash
func init --worker-runtime dotnet --force
```

![image](https://user-images.githubusercontent.com/34960418/167853137-589d2464-4cdb-43ff-8259-6081d9e1cb78.png)

Close the **Windows Terminal** application.


## Configure a connection string

Open folder with created Azure Functions project with **Visual Studio Code**.

```bash
code .
```

![image](https://user-images.githubusercontent.com/34960418/167853646-7616024b-4f18-430b-93bd-45c28eeeb4d6.png)

![image](https://user-images.githubusercontent.com/34960418/167854648-9d051915-09dd-439f-959c-590eb644e084.png)


On the **Explorer** pane of the **Visual Studio Code** window, open the **local.settings.json** file. Observe the current value of the **AzureWebJobsStorage** setting:

```json
"AzureWebJobsStorage": "UseDevelopmentStorage=true",
```

Update the value of the **AzureWebJobsStorage** by setting it to the **connection string** of the storage account that you recorded earlier in this lab. Save the **local.settings.json** file.


## Build and validate a project

Open **Windows Terminal**, change directory to function directory. Run the following command to **build** the .NET Core 3.1 project:

```bash
dotnet build
```


## Review

In this exercise, you created a local project that you'll use for Azure Functions development.


# Create a function that's triggered by an HTTP request

## Create an HTTP-triggered function

Open **Windows Terminal**, change directory to function directory. Run the following command to use the **Azure Functions Core Tools** to create a new function named **Echo** using the **HTTP trigger** template:

```bash
func new --template "HTTP trigger" --name "Echo"
```

![image](https://user-images.githubusercontent.com/34960418/167859717-242a4a52-2c42-40f6-bd24-1c84719eea26.png)


## Write HTTP-triggered function code

On the **Explorer** pane of the **Visual Studio Code** window, open the **Echo.cs** file. In the code editor, observe the example implementation:

```csharp
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

namespace Starter
{
    public static class Echo
    {
        [FunctionName("Echo")]
        public static async Task<IActionResult> Run(
            [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
            ILogger log)
        {
            log.LogInformation("C# HTTP trigger function processed a request.");

            string name = req.Query["name"];

            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
            dynamic data = JsonConvert.DeserializeObject(requestBody);
            name = name ?? data?.name;

            string responseMessage = string.IsNullOrEmpty(name)
                ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                : $"Hello, {name}. This HTTP triggered function executed successfully.";

            return new OkObjectResult(responseMessage);
        }
    }
}
```


Delete all the content within the **Echo.cs** file. Add the following lines of code to add **using directives** for the **Microsoft.AspNetCore.Mvc**, **Microsoft.Azure.WebJobs**, **Microsoft.AspNetCore.Http**, and **Microsoft.Extensions.Logging** namespaces:

```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
```


Create a new **public static** class named **Echo**:

```chsarp
public static class Echo
{
}
```


Within the **Echo** class, add the following code block to create a new **public static** method named **Run** that returns a variable of type **IActionResult** and that also takes in variables of type **HttpRequest** and **ILogger** as parameters named *request* and *logger*:

```csharp
public static IActionResult Run(
    HttpRequest request,
    ILogger logger)
{ 
}
```


Add the following code to append an attribute to the **Run** method of type **FunctionNameAttribute** that has its **name** parameter set to a value of **Echo**:

```csharp
[FunctionName("Echo")]
```


Add the following code to append an attribute to the **request** parameter of type **HttpTriggerAttribute** that has its **methods** parameter array set to a single value of **POST**:

```csharp
[HttpTrigger("POST")]
```


In the **Run** method, enter the following line of code to log a fixed message:

```csharp
logger.LogInformation("Received a request");
```


Enter the following line of code to echo the body of the HTTP request as the HTTP response:

```csharp
return new OkObjectResult(request.Body);
```


Observe the **Echo.cs** file again, which should now include the following code:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;

public static class Echo
{
    [FunctionName("Echo")]
    public static IActionResult Run(
        [HttpTrigger("POST")] HttpRequest request,
        ILogger logger)
    {
        logger.LogInformation("Received a request");
        return new OkObjectResult(request.Body);
    }
}
```

Select **Save** to save your changes to the **Echo.cs** file.


## Test the HTTP-triggered function by using httprepl

Open **Windows Terminal**, change directory to function directory. Run the following command to run the function app project:

```bash
func start --build
```

![image](https://user-images.githubusercontent.com/34960418/167863174-edcb73c8-d18d-48c9-9964-319d7be8cee9.png)

![image](https://user-images.githubusercontent.com/34960418/167863218-fb44230f-9cd5-47dc-85eb-2cc52f8ca8c7.png)


When you receive the open command prompt, run the following command to start the **httprepl** tool, setting the base Uniform Resource Identifier (URI) to ``http://localhost:7071``:

```bash
httprepl http://localhost:7071
```

![image](https://user-images.githubusercontent.com/34960418/167863945-7df05c89-15da-4eca-853c-541d531c7518.png)

> **Note**: An error message is displayed by the **httprepl** tool. This message occurs because the tool is searching for a Swagger definition file to use to traverse the API. Because your function project doesn't produce a Swagger definition file, you'll need to traverse the API manually.


When you receive the tool prompt, run the following command to browse to the relative **api** directory:

```bash
cd api
```


Run the following command to browse to the relative **echo** directory:

```bash
cd echo
```


Run the following command to run the **post** command, sending in an HTTP request body set to a numeric value of **3** by using the **\-\-content** option:

```bash
post --content 3
```

![image](https://user-images.githubusercontent.com/34960418/167864539-5b575977-cecf-47bf-9b75-a82c575b5dff.png)


Run the following commands to run the **post** command, sending in an HTTP request body set to a numeric value of **5** by using the **\-\-content** option:

```bash
post --content 5
post --content "Hello"
post --content "{"msg": "Successful"}"
```

![image](https://user-images.githubusercontent.com/34960418/167864837-a8c95c50-6533-43e6-a4ac-f4c104df717f.png)


Run the following command to exit the **httprepl** application:

```bash
exit
```


## Review

In this exercise, you created a basic function that echoes the content sent through an HTTP POST request.


# Create a function that triggers on a schedule

## Create a schedule-triggered function

Open **Windows Terminal**, change directory to function directory. Run the following command to use the **Azure Functions Core Tools** to create a new function named **Recurring**, using the **Timer trigger** template:

```bash
func new --template "Timer trigger" --name "Recurring"
```

![image](https://user-images.githubusercontent.com/34960418/167865675-a18541a9-ebe1-4fbf-bbc6-8dda5db46dbf.png)


## Observe function code

On the **Explorer** pane of the **Visual Studio Code** window, open the **Recurring.cs** file. In the code editor, observe the implementation:

```csharp
namespace Starter
{
    using System;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Host;
    using Microsoft.Extensions.Logging;
    
    public class Recurring
    {
        [FunctionName("Recurring")]
        public void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
        {
            log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}");
        }
    }
}
```


## Observe function runs

Open **Windows Terminal**, change directory to function directory. Run the following command to run the function app project:

```bash
func start --build
```

![image](https://user-images.githubusercontent.com/34960418/167866674-c8fd4822-33cd-4932-86a1-f0932156f118.png)
